import{ref as b,onServerPrefetch as x,unref as O,computed as C,isRef as F}from"vue";import{u as z}from"../server.mjs";const E=()=>null;function S(...r){var l,y,d,p,h,m,v,k,i;const c=typeof r[r.length-1]=="string"?r.pop():void 0;typeof r[0]!="string"&&r.unshift(c);let[a,s,e={}]=r;if(typeof a!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof s!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");e.server=(l=e.server)!=null?l:!0,e.default=(y=e.default)!=null?y:E,e.defer&&console.warn("[useAsyncData] `defer` has been renamed to `lazy`. Support for `defer` will be removed in RC."),e.lazy=(p=(d=e.lazy)!=null?d:e.defer)!=null?p:!1,e.initialCache=(h=e.initialCache)!=null?h:!0,e.immediate=(m=e.immediate)!=null?m:!0;const t=z(),f=()=>(t.isHydrating||e.initialCache)&&t.payload.data[a]!==void 0;t._asyncData[a]||(t._asyncData[a]={data:b(f()?t.payload.data[a]:(k=(v=e.default)==null?void 0:v.call(e))!=null?k:null),pending:b(!f()),error:b((i=t.payload._errors[a])!=null?i:null)});const n={...t._asyncData[a]};n.refresh=n.execute=(P={})=>t._asyncDataPromises[a]?t._asyncDataPromises[a]:P._initial&&f()?t.payload.data[a]:(n.pending.value=!0,t._asyncDataPromises[a]=new Promise((o,D)=>{try{o(s(t))}catch(_){D(_)}}).then(o=>{e.transform&&(o=e.transform(o)),e.pick&&(o=A(o,e.pick)),n.data.value=o,n.error.value=null}).catch(o=>{var D,_;n.error.value=o,n.data.value=O((_=(D=e.default)==null?void 0:D.call(e))!=null?_:null)}).finally(()=>{n.pending.value=!1,t.payload.data[a]=n.data.value,n.error.value&&(t.payload._errors[a]=!0),delete t._asyncDataPromises[a]}),t._asyncDataPromises[a]);const w=()=>n.refresh({_initial:!0});if(e.server!==!1&&t.payload.serverRendered&&e.immediate){const P=w();x(()=>P)}const u=Promise.resolve(t._asyncDataPromises[a]).then(()=>n);return Object.assign(u,n),u}function A(r,c){const a={};for(const s of c)a[s]=r[s];return a}function j(r,c,a){const[s={},e]=typeof c=="string"?[{},c]:[c,a],t=s.key||e;if(!t||typeof t!="string")throw new TypeError("[nuxt] [useFetch] key must be a string: "+t);if(!r)throw new Error("[nuxt] [useFetch] request is missing.");const f="$f"+t,n=C(()=>{let i=r;return typeof i=="function"&&(i=i()),F(i)?i.value:i}),{server:w,lazy:g,default:u,transform:l,pick:y,watch:d,initialCache:p,...h}=s,m={...h,cache:typeof s.cache=="boolean"?void 0:s.cache},v={server:w,lazy:g,default:u,transform:l,pick:y,initialCache:p,watch:[n,...d||[]]};return S(f,()=>$fetch(n.value,m),v)}export{j as u};
//# sourceMappingURL=fetch.48fede5b.js.map
