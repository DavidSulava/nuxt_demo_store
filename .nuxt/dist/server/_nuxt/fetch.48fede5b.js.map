{"version":3,"file":"fetch.48fede5b.js","sources":["../../../../node_modules/nuxt/dist/app/composables/asyncData.mjs","../../../../node_modules/nuxt/dist/app/composables/fetch.mjs"],"sourcesContent":["import { onBeforeMount, onServerPrefetch, onUnmounted, ref, getCurrentInstance, watch, unref } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.mjs\";\nconst getDefault = () => null;\nexport function useAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  let [key, handler, options = {}] = args;\n  if (typeof key !== \"string\") {\n    throw new TypeError(\"[nuxt] [asyncData] key must be a string.\");\n  }\n  if (typeof handler !== \"function\") {\n    throw new TypeError(\"[nuxt] [asyncData] handler must be a function.\");\n  }\n  options.server = options.server ?? true;\n  options.default = options.default ?? getDefault;\n  if (options.defer) {\n    console.warn(\"[useAsyncData] `defer` has been renamed to `lazy`. Support for `defer` will be removed in RC.\");\n  }\n  options.lazy = options.lazy ?? options.defer ?? false;\n  options.initialCache = options.initialCache ?? true;\n  options.immediate = options.immediate ?? true;\n  const nuxt = useNuxtApp();\n  const useInitialCache = () => (nuxt.isHydrating || options.initialCache) && nuxt.payload.data[key] !== void 0;\n  if (!nuxt._asyncData[key]) {\n    nuxt._asyncData[key] = {\n      data: ref(useInitialCache() ? nuxt.payload.data[key] : options.default?.() ?? null),\n      pending: ref(!useInitialCache()),\n      error: ref(nuxt.payload._errors[key] ?? null)\n    };\n  }\n  const asyncData = { ...nuxt._asyncData[key] };\n  asyncData.refresh = asyncData.execute = (opts = {}) => {\n    if (nuxt._asyncDataPromises[key]) {\n      return nuxt._asyncDataPromises[key];\n    }\n    if (opts._initial && useInitialCache()) {\n      return nuxt.payload.data[key];\n    }\n    asyncData.pending.value = true;\n    nuxt._asyncDataPromises[key] = new Promise(\n      (resolve, reject) => {\n        try {\n          resolve(handler(nuxt));\n        } catch (err) {\n          reject(err);\n        }\n      }\n    ).then((result) => {\n      if (options.transform) {\n        result = options.transform(result);\n      }\n      if (options.pick) {\n        result = pick(result, options.pick);\n      }\n      asyncData.data.value = result;\n      asyncData.error.value = null;\n    }).catch((error) => {\n      asyncData.error.value = error;\n      asyncData.data.value = unref(options.default?.() ?? null);\n    }).finally(() => {\n      asyncData.pending.value = false;\n      nuxt.payload.data[key] = asyncData.data.value;\n      if (asyncData.error.value) {\n        nuxt.payload._errors[key] = true;\n      }\n      delete nuxt._asyncDataPromises[key];\n    });\n    return nuxt._asyncDataPromises[key];\n  };\n  const initialFetch = () => asyncData.refresh({ _initial: true });\n  const fetchOnServer = options.server !== false && nuxt.payload.serverRendered;\n  if (process.server && fetchOnServer && options.immediate) {\n    const promise = initialFetch();\n    onServerPrefetch(() => promise);\n  }\n  if (process.client) {\n    const instance = getCurrentInstance();\n    if (instance && !instance._nuxtOnBeforeMountCbs) {\n      instance._nuxtOnBeforeMountCbs = [];\n      const cbs = instance._nuxtOnBeforeMountCbs;\n      if (instance) {\n        onBeforeMount(() => {\n          cbs.forEach((cb) => {\n            cb();\n          });\n          cbs.splice(0, cbs.length);\n        });\n        onUnmounted(() => cbs.splice(0, cbs.length));\n      }\n    }\n    if (fetchOnServer && nuxt.isHydrating && key in nuxt.payload.data) {\n      asyncData.pending.value = false;\n    } else if (instance && (nuxt.payload.serverRendered && nuxt.isHydrating || options.lazy) && options.immediate) {\n      instance._nuxtOnBeforeMountCbs.push(initialFetch);\n    } else if (options.immediate) {\n      initialFetch();\n    }\n    if (options.watch) {\n      watch(options.watch, () => asyncData.refresh());\n    }\n    const off = nuxt.hook(\"app:data:refresh\", (keys) => {\n      if (!keys || keys.includes(key)) {\n        return asyncData.refresh();\n      }\n    });\n    if (instance) {\n      onUnmounted(off);\n    }\n  }\n  const asyncDataPromise = Promise.resolve(nuxt._asyncDataPromises[key]).then(() => asyncData);\n  Object.assign(asyncDataPromise, asyncData);\n  return asyncDataPromise;\n}\nexport function useLazyAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  const [key, handler, options] = args;\n  return useAsyncData(key, handler, { ...options, lazy: true }, null);\n}\nexport function refreshNuxtData(keys) {\n  if (process.server) {\n    return Promise.resolve();\n  }\n  const _keys = keys ? Array.isArray(keys) ? keys : [keys] : void 0;\n  return useNuxtApp().callHook(\"app:data:refresh\", _keys);\n}\nexport function clearNuxtData(keys) {\n  const nuxtApp = useNuxtApp();\n  const _allKeys = Object.keys(nuxtApp.payload.data);\n  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : Array.isArray(keys) ? keys : [keys];\n  for (const key of _keys) {\n    if (key in nuxtApp.payload.data) {\n      nuxtApp.payload.data[key] = void 0;\n    }\n    if (key in nuxtApp.payload._errors) {\n      nuxtApp.payload._errors[key] = void 0;\n    }\n    if (nuxtApp._asyncData[key]) {\n      nuxtApp._asyncData[key].data.value = void 0;\n      nuxtApp._asyncData[key].error.value = void 0;\n      nuxtApp._asyncData[key].pending.value = false;\n    }\n    if (key in nuxtApp._asyncDataPromises) {\n      nuxtApp._asyncDataPromises[key] = void 0;\n    }\n  }\n}\nfunction pick(obj, keys) {\n  const newObj = {};\n  for (const key of keys) {\n    newObj[key] = obj[key];\n  }\n  return newObj;\n}\n","import { computed, isRef } from \"vue\";\nimport { useAsyncData } from \"./asyncData.mjs\";\nexport function useFetch(request, arg1, arg2) {\n  const [opts = {}, autoKey] = typeof arg1 === \"string\" ? [{}, arg1] : [arg1, arg2];\n  const _key = opts.key || autoKey;\n  if (!_key || typeof _key !== \"string\") {\n    throw new TypeError(\"[nuxt] [useFetch] key must be a string: \" + _key);\n  }\n  if (!request) {\n    throw new Error(\"[nuxt] [useFetch] request is missing.\");\n  }\n  const key = \"$f\" + _key;\n  const _request = computed(() => {\n    let r = request;\n    if (typeof r === \"function\") {\n      r = r();\n    }\n    return isRef(r) ? r.value : r;\n  });\n  const {\n    server,\n    lazy,\n    default: defaultFn,\n    transform,\n    pick,\n    watch,\n    initialCache,\n    ...fetchOptions\n  } = opts;\n  const _fetchOptions = {\n    ...fetchOptions,\n    cache: typeof opts.cache === \"boolean\" ? void 0 : opts.cache\n  };\n  const _asyncDataOptions = {\n    server,\n    lazy,\n    default: defaultFn,\n    transform,\n    pick,\n    initialCache,\n    watch: [\n      _request,\n      ...watch || []\n    ]\n  };\n  const asyncData = useAsyncData(key, () => {\n    return $fetch(_request.value, _fetchOptions);\n  }, _asyncDataOptions);\n  return asyncData;\n}\nexport function useLazyFetch(request, arg1, arg2) {\n  const [opts, autoKey] = typeof arg1 === \"string\" ? [{}, arg1] : [arg1, arg2];\n  return useFetch(\n    request,\n    {\n      ...opts,\n      lazy: true\n    },\n    autoKey\n  );\n}\n"],"names":["getDefault","useAsyncData","args","autoKey","key","handler","options","_a","_b","_d","_c","_e","_f","nuxt","useNuxtApp","useInitialCache","ref","_h","_g","_i","asyncData","opts","resolve","reject","err","result","pick","error","unref","initialFetch","promise","onServerPrefetch","asyncDataPromise","obj","keys","newObj","useFetch","request","arg1","arg2","_key","_request","computed","r","isRef","server","lazy","defaultFn","transform","watch","initialCache","fetchOptions","_fetchOptions","_asyncDataOptions"],"mappings":"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"}