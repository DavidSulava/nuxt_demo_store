import{e as O,r as x,f as P,g as C,h as z,u as F,i as B,j as E,k as M}from"./entry.b9a4a1e8.js";const R=()=>null;function j(...r){var p,m,v,_,D,w,g,k,f;const i=typeof r[r.length-1]=="string"?r.pop():void 0;typeof r[0]!="string"&&r.unshift(i);let[a,o,e={}]=r;if(typeof a!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof o!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");e.server=(p=e.server)!=null?p:!0,e.default=(m=e.default)!=null?m:R,e.defer&&console.warn("[useAsyncData] `defer` has been renamed to `lazy`. Support for `defer` will be removed in RC."),e.lazy=(_=(v=e.lazy)!=null?v:e.defer)!=null?_:!1,e.initialCache=(D=e.initialCache)!=null?D:!0,e.immediate=(w=e.immediate)!=null?w:!0;const t=O(),y=()=>(t.isHydrating||e.initialCache)&&t.payload.data[a]!==void 0;t._asyncData[a]||(t._asyncData[a]={data:x(y()?t.payload.data[a]:(k=(g=e.default)==null?void 0:g.call(e))!=null?k:null),pending:x(!y()),error:x((f=t.payload._errors[a])!=null?f:null)});const n={...t._asyncData[a]};n.refresh=n.execute=(u={})=>t._asyncDataPromises[a]?t._asyncDataPromises[a]:u._initial&&y()?t.payload.data[a]:(n.pending.value=!0,t._asyncDataPromises[a]=new Promise((c,s)=>{try{c(o(t))}catch(l){s(l)}}).then(c=>{e.transform&&(c=e.transform(c)),e.pick&&(c=A(c,e.pick)),n.data.value=c,n.error.value=null}).catch(c=>{var s,l;n.error.value=c,n.data.value=F((l=(s=e.default)==null?void 0:s.call(e))!=null?l:null)}).finally(()=>{n.pending.value=!1,t.payload.data[a]=n.data.value,n.error.value&&(t.payload._errors[a]=!0),delete t._asyncDataPromises[a]}),t._asyncDataPromises[a]);const d=()=>n.refresh({_initial:!0}),b=e.server!==!1&&t.payload.serverRendered;{const u=B();if(u&&!u._nuxtOnBeforeMountCbs){u._nuxtOnBeforeMountCbs=[];const s=u._nuxtOnBeforeMountCbs;u&&(P(()=>{s.forEach(l=>{l()}),s.splice(0,s.length)}),C(()=>s.splice(0,s.length)))}b&&t.isHydrating&&a in t.payload.data?n.pending.value=!1:u&&(t.payload.serverRendered&&t.isHydrating||e.lazy)&&e.immediate?u._nuxtOnBeforeMountCbs.push(d):e.immediate&&d(),e.watch&&z(e.watch,()=>n.refresh());const c=t.hook("app:data:refresh",s=>{if(!s||s.includes(a))return n.refresh()});u&&C(c)}const h=Promise.resolve(t._asyncDataPromises[a]).then(()=>n);return Object.assign(h,n),h}function A(r,i){const a={};for(const o of i)a[o]=r[o];return a}function H(r,i,a){const[o={},e]=typeof i=="string"?[{},i]:[i,a],t=o.key||e;if(!t||typeof t!="string")throw new TypeError("[nuxt] [useFetch] key must be a string: "+t);if(!r)throw new Error("[nuxt] [useFetch] request is missing.");const y="$f"+t,n=E(()=>{let f=r;return typeof f=="function"&&(f=f()),M(f)?f.value:f}),{server:d,lazy:b,default:h,transform:p,pick:m,watch:v,initialCache:_,...D}=o,w={...D,cache:typeof o.cache=="boolean"?void 0:o.cache},g={server:d,lazy:b,default:h,transform:p,pick:m,initialCache:_,watch:[n,...v||[]]};return j(y,()=>$fetch(n.value,w),g)}function T(r,i,a){const[o,e]=typeof i=="string"?[{},i]:[i,a];return H(r,{...o,lazy:!0},e)}export{H as a,T as u};
